
//
//  KCSUser2+KinveyUserService.m
//  KinveyKit
//
//  Created by Michael Katz on 12/10/13.
//  Copyright (c) 2013-2015 Kinvey. All rights reserved.
//
// This software is licensed to you under the Kinvey terms of service located at
// http://www.kinvey.com/terms-of-use. By downloading, accessing and/or using this
// software, you hereby accept such terms of service  (and any agreement referenced
// therein) and agree that you have read, understand and agree to be bound by such
// terms of service and are of legal age to agree to such terms with Kinvey.
//
// This software contains valuable confidential and proprietary information of
// KINVEY, INC and is subject to applicable licensing agreements.
// Unauthorized reproduction, transmission or distribution of this file and its
// contents is a violation of applicable laws.
//

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated"

#import "KCSUser2+KinveyUserService.h"

#import "KinveyCoreInternal.h"
#import "KinveyDataStoreInternal.h"
#import "KinveyErrorCodes.h"
KK2(Cleanup!)
#import "KinveyUser.h"
#import "KCSHiddenMethods.h"
#import "KCSDataModel.h"
#import "KCSPush.h"

#import "NSString+KinveyAdditions.h"
#import "NSURL+KinveyAdditions.h"
#import "NSDictionary+KinveyAdditions.h"

#import "KCSURLConnectionDelegateAdapter.h"
#import "KCSRequest+Private.h"
#import "KCSMICRequest2.h"
#import "KCSClient+Private.h"
#import "KCSHttpRequest+Private.h"
#import <Kinvey/Kinvey-Swift.h>

#define KCSEntityKeyKMD @"_kmd"
#define KCSEntityKeyAuthtoken @"authtoken"
#define KCSEntityKeyEmailVerification @"emailVerification"
#define KCSUserAttributePassword @"password"

NSString* const kKCSMICRefreshTokenKey = @"refresh_token";
NSString* const kKCSMICRedirectURIKey = @"redirect_uri";

@implementation KCSUser2 (KinveyUserService)

#pragma mark - Credential Management

+ (BOOL) hasSavedCredentials
{
    return [KCSKeychain2 hasTokens];
}

+ (BOOL) clearSavedCredentials
{
    return [KCSKeychain2 deleteTokens];
}

+ (void) setActive:(id<KCSUser2>)user
{
    KK2(manage active user here)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated"
    [KCSClient sharedClient].currentUser = (id)user;
#pragma clang diagnostic pop
}

+ (id<KCSUser2>)activeUser
{
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated"
    return (id)[KCSClient sharedClient].currentUser;
#pragma clang diagnostic pop
}

#pragma mark - User Creation

+(KCSRequest*)createAutogeneratedUser:(NSDictionary *)fieldsAndValues
                           completion:(KCSUser2CompletionBlock)completionBlock
{
    SWITCH_TO_MAIN_THREAD_USER2_BLOCK(completionBlock);
    return [self createUserWithUsername:nil password:nil fieldsAndValues:fieldsAndValues completion:completionBlock];
}

+(KCSRequest*)createUserWithUsername:(NSString *)username
                            password:(NSString *)password
                     fieldsAndValues:(NSDictionary *)fieldsAndValues
                          completion:(KCSUser2CompletionBlock)completionBlock
{
    SWITCH_TO_MAIN_THREAD_USER2_BLOCK(completionBlock);
    if (!completionBlock) [[NSException exceptionWithName:NSInvalidArgumentException reason:@"Completion Block is nil" userInfo:nil] raise];
    if ((password == nil && username != nil) || (username == nil && password != nil)) {
        [[NSException exceptionWithName:NSInvalidArgumentException reason:@"Both username and password need to be set or both nil" userInfo:nil] raise];
    }
    
    NSMutableDictionary* createUserBody = [NSMutableDictionary dictionaryWithDictionary:fieldsAndValues];
    if (username && password) {
        createUserBody[KCSUserAttributeUsername] = username;
        createUserBody[KCSUserAttributePassword] = password;
    }
    
    KCSHttpRequest* request = [KCSHttpRequest requestWithCompletion:^(KCSNetworkResponse *response, NSError *error) {
        if (error) {
            KCSLogNSError(KCS_LOG_CONTEXT_USER, error);
            [self setActive:nil];
            if (completionBlock) completionBlock(nil, error);
        } else {
            // Ok, we're really auth'd
            NSError* error = nil;
            NSDictionary* userBody = [response jsonObjectError:&error];
            if (error) {
                if (completionBlock) completionBlock(nil, error);
            } else {
                [self setupActiveUser:userBody completion:completionBlock checkAuth:YES];
            }
        }
    }
                                                        route:KCSRESTRouteUser
                                                      options:@{KCSRequestLogMethod}
                                                  credentials:[KCSClient2 sharedClient]];
    request.body = createUserBody;
    request.method = KCSRESTMethodPOST;
    return [KCSRequest requestWithNetworkOperation:[request start]];
}

+ (void)createWithAuthProvider:(KCSUserSocialIdentifyProvider)provider
                     loginBody:(NSDictionary*)body
                        client:(KNVClient*)client
                    completion:(KCSUser2CompletionBlock)completionBlock;
{
    KCSHttpRequest* request = [KCSHttpRequest requestWithCompletion:^(KCSNetworkResponse *response, NSError *error) {
        if (error) {
            KCSLogNSError(KCS_LOG_CONTEXT_USER, error);
            [self setActive:nil];
            if (completionBlock) completionBlock(nil, error);
        } else {
            // Ok, we're really auth'd
            NSDictionary* userBody = [response jsonObjectError:&error];
            if (error) {
                if (completionBlock) completionBlock(nil, error);
            } else {
                [self setupActiveUser:userBody completion:completionBlock checkAuth:YES];
            }
        }
    }
                                                              route:KCSRESTRouteUser
                                                            options:@{KCSRequestLogMethod}
                                                        credentials:[KCSClient2 sharedClient]
                                                             client:client];
    request.method = KCSRESTMethodPOST;
    request.body = body;
    [request start];
}


#pragma mark - Login
+(KCSRequest*)loginWithUsername:(NSString *)username
                       password:(NSString *)password
                     completion:(KCSUser2CompletionBlock)completionBlock
{
    SWITCH_TO_MAIN_THREAD_USER2_BLOCK(completionBlock);
    if (!username) [[NSException exceptionWithName:NSInvalidArgumentException reason:@"username should not be nil." userInfo:nil] raise];
    if (!password) [[NSException exceptionWithName:NSInvalidArgumentException reason:@"password should not be nil." userInfo:nil] raise];
    
    KCSHttpRequest* request = [KCSHttpRequest requestWithCompletion:^(KCSNetworkResponse *response, NSError *error) {
        if (error) {
            KCSLogNSError(KCS_LOG_CONTEXT_USER, error);
            [self setActive:nil];
            if (completionBlock) completionBlock(nil, error);
        } else {
            // Ok, we're really auth'd
            NSDictionary* userBody = [response jsonObjectError:&error];
            if (error) {
                if (completionBlock) completionBlock(nil, error);
            } else {
                [self setupActiveUser:userBody completion:completionBlock checkAuth:YES];
            }
        }
    }
                                                        route:KCSRESTRouteUser
                                                      options:@{KCSRequestLogMethod}
                                                  credentials:[KCSClient2 sharedClient]];
    request.path = @[@"login"];
    request.method = KCSRESTMethodPOST;
    request.body = @{@"username":username, @"password":password};
    return [KCSRequest requestWithNetworkOperation:[request start]];
}

+(KCSRequest*)connectWithAuthProvider:(KCSUserSocialIdentifyProvider)provider
                     accessDictionary:(NSDictionary*)accessDictionary
                           completion:(KCSUser2CompletionBlock)completionBlock
{
    return [self connectWithAuthProvider:provider
                        accessDictionary:accessDictionary
                                  client:[KCSClient sharedClient].client
                              completion:completionBlock];
}

+(KCSRequest*)connectWithAuthProvider:(KCSUserSocialIdentifyProvider)provider
                     accessDictionary:(NSDictionary*)accessDictionary
                               client:(KNVClient*)client
                           completion:(KCSUser2CompletionBlock)completionBlock
{
    SWITCH_TO_MAIN_THREAD_USER2_BLOCK(completionBlock);
    NSDictionary* loginDict = [self loginDictForProvider:provider accessDictionary:accessDictionary];
    
    KCSHttpRequest* request = [KCSHttpRequest requestWithCompletion:^(KCSNetworkResponse *response, NSError *error) {
        if (error) {
            if (response.isKCSError == YES && response.code == KCSNotFoundError) {
                //This is new user, create
                [self createWithAuthProvider:provider
                                   loginBody:loginDict
                                      client:client
                                  completion:completionBlock];
            } else {
                KCSLogNSError(KCS_LOG_CONTEXT_USER, error);
                [self setActive:nil];
                if (completionBlock) completionBlock(nil, error);
            }
        } else {
            // Ok, we're really auth'd
            NSMutableDictionary* userBody = [NSMutableDictionary dictionaryWithDictionary:[response jsonObjectError:&error]];
            if (error) {
                if (completionBlock) completionBlock(nil, error);
            } else {
                if (provider == KCSSocialIDKinvey) {
                    NSMutableDictionary* kinveyAuth = [NSMutableDictionary dictionaryWithDictionary:userBody[@"_socialIdentity"][@"kinveyAuth"]];
                    kinveyAuth[kKCSMICRedirectURIKey] = accessDictionary[kKCSMICRedirectURIKey];
                    NSDictionary *socialIdentity = userBody[@"_socialIdentity"];
                    userBody[@"_socialIdentity"] = socialIdentity.mutableCopy;
                    userBody[@"_socialIdentity"][@"kinveyAuth"] = kinveyAuth;
                }
                [self setupActiveUser:userBody completion:completionBlock checkAuth:YES];
            }
        }
    }
                                                              route:KCSRESTRouteUser
                                                            options:@{KCSRequestLogMethod}
                                                        credentials:[KCSClient2 sharedClient]
                                                             client:client];
    request.path = @[@"login"];
    request.method = KCSRESTMethodPOST;
    request.body = loginDict;
    request.client = client;
    return [KCSRequest requestWithNetworkOperation:[request start]];
}

+(KCSClientConfiguration*)clientConfiguration
{
    KCSClientConfiguration* config = [KCSClient2 sharedClient].configuration;
    if (!config) {
        config = [KCSClient sharedClient].configuration;
    }
    return config;
}

#if TARGET_OS_IOS

+(void)loginWithAuthorizationCodeLoginPage:(NSString *)redirectURI
{
    NSURL* url = [self URLforLoginWithMICRedirectURI:redirectURI
                                         isLoginPage:YES];
    [[UIApplication sharedApplication] openURL:url];
}

/**
 MIC step 1 => get the temp_login_uri
 */
+(KCSRequest*)loginWithAuthorizationCodeAPI:(NSString *)redirectURI
                                    options:(NSDictionary *)options
                                 completion:(KCSUser2CompletionBlock)completionBlock
{
    __block KCSRequest* req = nil;
    if (completionBlock) {
        KCSUser2CompletionBlock completionBlockOriginal = completionBlock;
        completionBlock = ^(id<KCSUser2>user, NSError* error) {
            if (!req.isCancelled) {
                completionBlockOriginal(user, error);
            }
        };
    }
    SWITCH_TO_MAIN_THREAD_USER2_BLOCK(completionBlock);
    KCSMICRequest2* request = [KCSMICRequest2 requestWithRedirectURI:redirectURI
                                                          completion:^(KCSNetworkResponse *networkResponse, NSError *error)
    {
        if (error) {
            if (completionBlock) completionBlock(nil, error);
        } else {
            NSError* jsonParseError = nil;
            NSMutableDictionary* jsonResponse = [NSJSONSerialization JSONObjectWithData:networkResponse.jsonData
                                                                                options:NSJSONReadingMutableContainers
                                                                                  error:&jsonParseError];
            if (networkResponse.code == 200 && networkResponse.jsonData) {
                if (error) {
                    if (completionBlock) completionBlock(nil, error);
                } else {
                    [self oAuthAuthenticateWithURL:[NSURL URLWithString:jsonResponse[@"temp_login_uri"]]
                                       redirectURI:redirectURI
                                           options:options
                                        completion:completionBlock];
                }
            } else {
                if (completionBlock) {
                    NSError* error = jsonParseError;
                    if (!error) {
                        error = [NSError errorWithDomain:[NSHTTPURLResponse localizedStringForStatusCode:networkResponse.code]
                                                    code:networkResponse.code
                                                userInfo:jsonResponse];
                    }
                    completionBlock(nil, error);
                }
            }
        }
    }];
    req = [KCSRequest requestWithNetworkOperation:[request start]];
    return req;
}

/**
 MIC step 2 => get the hash code from the redirect URL with a custom scheme. something like kinveyAuthDemo://?code=b5aa3dc5f83feb51d45f34df68a5165d64b1e59b
 */
+(void)oAuthAuthenticateWithURL:(NSURL*)url
                    redirectURI:(NSString *)redirectURI
                        options:(NSDictionary *)optons
                     completion:(KCSUser2CompletionBlock)completionBlock
{
    NSMutableURLRequest* request = [KCSHttpRequest requestForURL:url];
    request.HTTPMethod = @"POST";
    request.HTTPBody = [@{
        @"client_id" : [self clientConfiguration].appKey,
        kKCSMICRedirectURIKey : redirectURI,
        @"response_type" : @"code",
        KCSUsername : optons[KCSUsername],
        KCSPassword : optons[KCSPassword]
    }.queryString dataUsingEncoding:NSUTF8StringEncoding];
    
    [request setValue:@(request.HTTPBody.length).stringValue
   forHTTPHeaderField:@"Content-Length"];
    
    [request setValue:@"application/x-www-form-urlencoded"
   forHTTPHeaderField:@"Content-Type"];
    
    __block NSURLRequest* redirectRequest = nil;
    KCSURLConnectionDelegateAdapter* connectionDelegateAdapter = [[KCSURLConnectionDelegateAdapter alloc] init];
    [connectionDelegateAdapter setConnectionWillSendRequestRedirectResponse:^NSURLRequest *(NSURLConnection *connection, NSURLRequest *request, NSURLResponse *response) {
        if (response) {
            redirectRequest = request;
            return nil;
        }
        
        return request;
    }];
    [connectionDelegateAdapter setCompletionBlock:^(NSURLResponse *response, NSData *data, NSError *error) {
        if (error) {
            if (completionBlock) completionBlock(nil, error);
        } else if ([response isKindOfClass:[NSHTTPURLResponse class]]) {
            NSHTTPURLResponse* httpResponse = (NSHTTPURLResponse*) response;
            if (httpResponse.statusCode == 302) { //redirect
                if (error) {
                    if (completionBlock) completionBlock(nil, error);
                } else {
                    if ([self isValidMICRedirectURI:redirectURI
                                              forURL:redirectRequest.URL]) {
                        [self parseMICRedirectURI:redirectURI
                                           forURL:redirectRequest.URL
                              withCompletionBlock:completionBlock];
                    } else {
                        if (completionBlock) completionBlock(nil, [NSError errorWithDomain:@"Invalid MIC Redirect URL"
                                                                                      code:400
                                                                                  userInfo:@{}]);
                    }
                }
            } else {
                if (completionBlock) {
                    completionBlock(nil, [NSError errorWithDomain:[NSHTTPURLResponse localizedStringForStatusCode:httpResponse.statusCode]
                                                             code:httpResponse.statusCode
                                                         userInfo:@{}]);
                }
            }
        } else if (completionBlock) {
            completionBlock(nil, [NSError errorWithDomain:@"Bad Request"
                                                     code:400
                                                 userInfo:@{}]);
        }
    }];
    
    NSURLConnection* connection = [[NSURLConnection alloc] initWithRequest:request
                                                                  delegate:connectionDelegateAdapter
                                                          startImmediately:NO];
    [connection setDelegateQueue:[KCSHttpRequest requestQueue]];
    [connection start];
}

+(BOOL)isValidMICRedirectURI:(NSString *)redirectURI
                      forURL:(NSURL *)url
{
    return [self isValidMICRedirectURI:redirectURI
                                forURL:url
                                params:nil];
}

+(BOOL)isValidMICRedirectURI:(NSString *)redirectURI
                      forURL:(NSURL *)url
                      params:(NSDictionary**)params
{
    NSURL* redirectURL = [NSURL URLWithString:redirectURI];
    if ([url.scheme compare:redirectURL.scheme options:NSCaseInsensitiveSearch] != NSOrderedSame ||
        (url.host && redirectURL.host && ![url.host isEqualToString:redirectURL.host]))
    {
        return NO;
    }
    
    NSArray* queryParamsParts = [url.query componentsSeparatedByCharactersInSet:[NSCharacterSet characterSetWithCharactersInString:@"?&"]];
    NSMutableDictionary* queryParams = [NSMutableDictionary dictionary];
    NSArray* keyValue;
    for (NSUInteger i = 0; i < queryParamsParts.count; i++) {
        keyValue = [queryParamsParts[i] componentsSeparatedByString:@"="];
        if (keyValue.count > 0) {
            queryParams[keyValue[0]] = keyValue.count > 1 ? keyValue[1] : @"";
        }
    }
    
    if (params) {
        *params = queryParams;
    }
    
    NSString* code = queryParams[@"code"];
    
    return code != nil && code.length > 0;
}

+(void)parseMICRedirectURI:(NSString *)redirectURI
                    forURL:(NSURL *)url
       withCompletionBlock:(KCSUser2CompletionBlock)completionBlock
{
    [self parseMICRedirectURI:redirectURI
                       forURL:url
                       client:[KCSClient sharedClient].client
          withCompletionBlock:completionBlock];
}

+(void)parseMICRedirectURI:(NSString *)redirectURI
                    forURL:(NSURL *)url
                    client:(KNVClient*)client
       withCompletionBlock:(KCSUser2CompletionBlock)completionBlock
{
    SWITCH_TO_MAIN_THREAD_USER2_BLOCK(completionBlock);
    NSDictionary* queryParams = nil;
    if ([self isValidMICRedirectURI:redirectURI
                             forURL:url
                             params:&queryParams]) {
        [self oAuthTokenWithCode:queryParams[@"code"]
                     redirectURI:redirectURI
                          client:client
                      completion:completionBlock];
    }
}

+(void)oAuthTokenWithCode:(NSString*)code
              redirectURI:(NSString *)redirectURI
               completion:(KCSUser2CompletionBlock)completionBlock
{
    [self oAuthTokenWithCode:code
                 redirectURI:redirectURI
                      client:[KCSClient sharedClient].client
                  completion:completionBlock];
}

+(void)oAuthTokenWithCode:(NSString*)code
              redirectURI:(NSString *)redirectURI
                   client:(KNVClient*)client
               completion:(KCSUser2CompletionBlock)completionBlock
{
    [self oAuthTokenWithToken:code
                      refresh:NO
                  redirectURI:redirectURI
                       client:client
                   completion:completionBlock];
}

+(void)oAuthTokenWithRefreshToken:(NSString*)refreshToken
                      redirectURI:(NSString*)redirectURI
                             sync:(BOOL)sync
                       completion:(KCSUser2CompletionBlock)completionBlock
{
    [self oAuthTokenWithToken:refreshToken
                      refresh:YES
                  redirectURI:redirectURI
                         sync:sync
                   completion:completionBlock];
}

+(void)oAuthTokenWithToken:(NSString*)token
                   refresh:(BOOL)refresh
               redirectURI:(NSString*)redirectURI
                completion:(KCSUser2CompletionBlock)completionBlock
{
    [self oAuthTokenWithToken:token
                      refresh:refresh
                  redirectURI:redirectURI
                       client:[KCSClient sharedClient].client
                   completion:completionBlock];
}

+(void)oAuthTokenWithToken:(NSString*)token
                   refresh:(BOOL)refresh
               redirectURI:(NSString*)redirectURI
                    client:(KNVClient*)client
                completion:(KCSUser2CompletionBlock)completionBlock
{
    [self oAuthTokenWithToken:token
                      refresh:refresh
                  redirectURI:redirectURI
                         sync:NO
                       client:client
                   completion:completionBlock];
}

/**
 MIC step 3 => change the temporary (or an expired token) token for a valid token (with an expiration time)
 */
+(void)oAuthTokenWithToken:(NSString*)token
                   refresh:(BOOL)refresh
               redirectURI:(NSString*)redirectURI
                      sync:(BOOL)sync
                completion:(KCSUser2CompletionBlock)completionBlock
{
    [self oAuthTokenWithToken:token
                      refresh:refresh
                  redirectURI:redirectURI
                         sync:sync
                       client:[KCSClient sharedClient].client
                   completion:completionBlock];
}

+(void)oAuthTokenWithToken:(NSString*)token
                   refresh:(BOOL)refresh
               redirectURI:(NSString*)redirectURI
                      sync:(BOOL)sync
                    client:(KNVClient*)client
                completion:(KCSUser2CompletionBlock)completionBlock
{
    NSURL* url = [NSURL URLWithString:[NSString stringWithFormat:@"%@/token", [self baseMicURLForClient:client]]];
    NSMutableURLRequest* request = [KCSHttpRequest requestForURL:url client:client];
    request.HTTPMethod = @"POST";
    
    NSDictionary* bodyParams;
    if (refresh) {
        bodyParams = @{
            @"client_id" : client.appKey,
            kKCSMICRedirectURIKey : redirectURI,
            @"grant_type" : @"refresh_token",
            kKCSMICRefreshTokenKey : token
        };
    } else {
        bodyParams = @{
            @"client_id" : client.appKey,
            kKCSMICRedirectURIKey : redirectURI,
            @"grant_type" : @"authorization_code",
            @"code" : token
        };
    }
    
    request.HTTPBody = [bodyParams.queryString dataUsingEncoding:NSUTF8StringEncoding];
    
    [request setValue:@(request.HTTPBody.length).stringValue
   forHTTPHeaderField:@"Content-Length"];
    
    [request setValue:@"application/x-www-form-urlencoded"
   forHTTPHeaderField:@"Content-Type"];
    
    NSString* basicAuthHash = [[[NSString stringWithFormat:@"%@:%@", client.appKey, client.appSecret] dataUsingEncoding:NSUTF8StringEncoding] base64EncodedStringWithOptions:0];
    [request setValue:[NSString stringWithFormat:@"Basic %@", basicAuthHash]
   forHTTPHeaderField:@"Authorization"];
    
    void (^block)(NSURLResponse*, NSData*, NSError*) = ^(NSURLResponse *response, NSData *data, NSError *error)
    {
        if (error) {
            if (completionBlock) completionBlock(nil, error);
        } else if ([response isKindOfClass:[NSHTTPURLResponse class]]) {
            NSHTTPURLResponse* httpResponse = (NSHTTPURLResponse*) response;
            if (httpResponse.statusCode == 200 && data) {
                NSMutableDictionary* jsonResponse = [NSJSONSerialization JSONObjectWithData:data
                                                                                    options:NSJSONReadingMutableContainers
                                                                                      error:&error];
                if (error) {
                    if (completionBlock) completionBlock(nil, error);
                } else {
                    NSMutableDictionary* response = [NSMutableDictionary dictionaryWithDictionary:jsonResponse];
                    response[kKCSMICRedirectURIKey] = redirectURI;
                    [self connectWithAuthProvider:KCSSocialIDKinvey
                                 accessDictionary:response
                                           client:client
                                       completion:completionBlock];
                }
            } else {
                if (completionBlock) {
                    completionBlock(nil, [NSError errorWithDomain:[NSHTTPURLResponse localizedStringForStatusCode:httpResponse.statusCode]
                                                             code:httpResponse.statusCode
                                                         userInfo:@{}]);
                }
            }
        } else if (completionBlock) {
            completionBlock(nil, [NSError errorWithDomain:@"Bad Request"
                                                     code:400
                                                 userInfo:@{}]);
        }
    };
    
    if (sync) {
        NSURLResponse* response = nil;
        NSError* error = nil;
        NSData* data = [NSURLConnection sendSynchronousRequest:request
                                             returningResponse:&response
                                                         error:&error];
        block(response, data, error);
    } else {
        [NSURLConnection sendAsynchronousRequest:request
                                           queue:[KCSHttpRequest requestQueue]
                               completionHandler:block];
    }
}

static NSString* micApiVersion = nil;

+(void)setMICApiVersion:(NSString *)_micApiVersion
{
    micApiVersion = _micApiVersion;
}

+(NSString *)micApiVersion
{
    return micApiVersion;
}

+(NSMutableString*)baseMicURL
{
    return [self baseMicURLForClient:[KCSClient sharedClient].client];
}

+(NSMutableString*)baseMicURLForClient:(KNVClient*)client
{
    NSString* hostProtocol = client.authHostName.scheme;
    
    NSString* hostDomain = client.authHostName.host;
    
    NSString* hostPort = @"";
    if (client.authHostName.port) {
        hostPort = [NSString stringWithFormat:@":%@", client.authHostName.port];
    }
    
    NSMutableString* baseURL = [NSMutableString stringWithFormat:@"%@://%@%@", hostProtocol, hostDomain, hostPort];
    if (micApiVersion && micApiVersion.length > 0) {
        [baseURL appendFormat:@"/%@", micApiVersion];
    }
    [baseURL appendString:@"/oauth"];
    return baseURL;
}

+(NSURL *)URLforLoginWithMICRedirectURI:(NSString *)redirectURI
{
    return [self URLforLoginWithMICRedirectURI:redirectURI
                                   isLoginPage:YES];
}

+(NSURL *)URLforLoginWithMICRedirectURI:(NSString *)redirectURI
                                 client:(KNVClient*)client
{
    return [self URLforLoginWithMICRedirectURI:redirectURI
                                   isLoginPage:YES
                                        client:client];
}

+(NSURL *)URLforLoginWithMICRedirectURI:(NSString *)redirectURI
                            isLoginPage:(BOOL)isLoginPage
{
    return [self URLforLoginWithMICRedirectURI:redirectURI
                                   isLoginPage:isLoginPage
                                        client:[KCSClient sharedClient].client];
}

+(NSURL *)URLforLoginWithMICRedirectURI:(NSString *)redirectURI
                            isLoginPage:(BOOL)isLoginPage
                                 client:(KNVClient*)client
{
    if (!client) client = [KCSClient sharedClient].client;
    NSMutableString *url = [NSMutableString stringWithFormat:@"%@/auth", [self baseMicURLForClient:client]];
    if (isLoginPage) {
        NSString* query = @{
            @"client_id" : client.appKey,
            kKCSMICRedirectURIKey : redirectURI,
            @"response_type" : @"code"
        }.queryString;
        [url appendFormat:@"?%@", query];
        return [NSURL URLWithString:url];
    }
    
    return [NSURL URLWithString:url];
}

#endif

+ (NSDictionary*) loginDictForProvider:(KCSUserSocialIdentifyProvider)provder accessDictionary:(NSDictionary*)accessDictionary
{
    NSDictionary* dict = @{};
    NSString* accessToken = [accessDictionary objectForKey:KCSUserAccessTokenKey];
    NSString* accessTokenSecret = [accessDictionary objectForKey:KCSUserAccessTokenSecretKey];
    switch (provder) {
        case KCSSocialIDFacebook: {
            NSString* appId = [accessDictionary objectForKey:KCS_FACEBOOK_APP_KEY];
            if (appId == nil) {
                appId = [[KCSClient sharedClient].options objectForKey:KCS_FACEBOOK_APP_KEY];
                if (appId == nil) {
                    appId = [[NSBundle mainBundle] objectForInfoDictionaryKey:@"FacebookAppID"];
                    if (appId == nil) {
                        // could not locate in the access dictionary, client, or plist, error
                        KCSLogWarn(KCS_LOG_CONTEXT_USER, @"No Facebook App Id provided in access dictionary, or KCSClient options key");
                        DBAssert(appId != nil, @"No Facebook App Id provided");
                    }
                }
            }
            dict = appId != nil ?  @{@"_socialIdentity" : @{@"facebook" : @{@"access_token" : accessToken, @"appid" : appId}}} :
            @{@"_socialIdentity" : @{@"facebook" : @{@"access_token" : accessToken}}};
        }
            break;
        case KCSSocialIDTwitter: {
            NSString* twitterKey = [[KCSClient sharedClient].options objectForKey:KCS_TWITTER_CLIENT_KEY];
            NSString* twitterSecret = [[KCSClient sharedClient].options objectForKey:KCS_TWITTER_CLIENT_SECRET];
            DBAssert(twitterKey != nil && twitterSecret != nil, @"twitter info should not be nil.");
            if (twitterKey != nil && twitterSecret != nil) {
                dict = @{@"_socialIdentity" : @{@"twitter" : @{@"access_token" : accessToken,
                                                               @"access_token_secret" : accessTokenSecret,
                                                               @"consumer_key" : twitterKey,
                                                               @"consumer_secret" : twitterSecret}}};
            }
        }
            break;
        case KCSSocialIDGooglePlus: {
            NSString* clientID = [KCSClient sharedClient].options[KCS_GOOGLE_PLUS_CLIENT_ID];
            NSString* clientSecret = [KCSClient sharedClient].options[KCS_GOOGLE_PLUS_CLIENT_SECRET];
            NSString* refreshToken = accessDictionary[KCSUserAccessRefreshTokenKey];
            NSNumber* expiresIn = accessDictionary[KCSUserAccessExpiresInKey];
            
            dict = @{
                @"_socialIdentity" : @{
                    @"google" : @{
                        @"client_id" : clientID != nil ? clientID : [NSNull null],
                        @"client_secret" : clientSecret != nil ? clientSecret : [NSNull null],
                        KCSUserAccessTokenKey : accessToken,
                        KCSUserAccessRefreshTokenKey : refreshToken != nil ? refreshToken : [NSNull null],
                        KCSUserAccessExpiresInKey : expiresIn != nil ? expiresIn : [NSNull null]
                    }
                }
            };
        }
            break;
        case KCSSocialIDLinkedIn: {
            NSString* linkedInKey = [[KCSClient sharedClient].options objectForKey:KCS_LINKEDIN_API_KEY];
            NSString* linkedInSecret = [[KCSClient sharedClient].options objectForKey:KCS_LINKEDIN_SECRET_KEY];
            DBAssert(linkedInKey != nil && linkedInSecret != nil, @"LinkedIn info should not be nil.");
            if (linkedInKey != nil && linkedInSecret != nil) {
                dict = @{@"_socialIdentity" : @{@"linkedIn" : @{@"access_token" : accessToken,
                                                                @"access_token_secret" : accessTokenSecret,
                                                                @"consumer_key" : linkedInKey,
                                                                @"consumer_secret" : linkedInSecret}}};
            }
        }
            break;
        case KCSSocialIDSalesforce: {
            NSString* idUrl = [accessDictionary objectForKey:KCS_SALESFORCE_IDENTITY_URL];
            NSString* refreshToken = [accessDictionary objectForKey:KCS_SALESFORCE_REFRESH_TOKEN];
            NSString* clientId = [accessDictionary objectForKey:KCS_SALESFORCE_CLIENT_ID];
            if (clientId == nil) {
                clientId = [[KCSClient sharedClient].options objectForKey:KCS_SALESFORCE_CLIENT_ID];
            }
            DBAssert(idUrl != nil, @"salesForce info should not be nil.");
            if (idUrl != nil && accessToken != nil) {
                dict = @{@"_socialIdentity" : @{@"salesforce" : @{@"access_token" : accessToken,
                                                                  KCS_SALESFORCE_IDENTITY_URL : idUrl,
                                                                  KCS_SALESFORCE_REFRESH_TOKEN: refreshToken,
                                                                  KCS_SALESFORCE_CLIENT_ID : clientId}}};
            }
            
        }
            break;
        case KCSSocialIDKinvey: {
            dict = @{
                @"_socialIdentity" : @{
                    @"kinveyAuth" : @{
                        KCSUserAccessTokenKey : accessDictionary[KCSUserAccessTokenKey]
                    }
                }
            };
        }
            break;
        default:
            dict = accessDictionary;
    }
    return dict;
}

#pragma mark - Logout

+ (void) logoutUser:(id<KCSUser2>)user
{
    if (![user isEqual:[KCSUser activeUser]]){
        KCSLogError(KCS_LOG_CONTEXT_USER, @"Attempted to log out a user who is not the KCS Current User!");
    } else {
        
        // Extract all of the items from the Array into a set, so adding the "new" device token does
        // the right thing.  This might be less efficient than just iterating, but these routines have
        // been optimized, we do this now, since there's no other place guarenteed to merge.
        // Login/create store this info
        
        //TODO: comment out to keep the user from being f'ed up. Reinstate once working on the server-side.
        //        KCSDevice *sp = [KCSDevice currentDevice];
        //
        //        if (sp.deviceToken != nil){
        //            NSMutableSet *tmpSet = [NSMutableSet setWithArray:self.deviceTokens];
        //            [tmpSet removeObject:[sp deviceTokenString]];
        //            self.deviceTokens = [tmpSet allObjects];
        //            [self saveToCollection:[KCSCollection userCollection] withCompletionBlock:^(NSArray *objectsOrNil, NSError *errorOrNil) {
        //                if (errorOrNil) {
        //                    KCSLogError(@"Error saving user when removing device tokens: %@", errorOrNil);
        //                }
        //            } withProgressBlock:nil];
        //        }
#if TARGET_OS_IOS
        [[KCSPush sharedPush] setDeviceToken:nil];
#endif
        
        [KCSUser2 clearSavedCredentials];
        [[KCSAppdataStore caches] clear];
        [KCSFileStore clearCachedFiles];
        
        // Set the currentUser to nil
        [self setActive:nil];
    }
}

#pragma mark - User Object Management
+(void)setupActiveUser:(NSDictionary*)body
            completion:(KCSUser2CompletionBlock)completionBlock
             checkAuth:(BOOL)checkAuth
{
    if (![body isKindOfClass:[NSDictionary class]]) {
        //check data type in case server is corrupted, yes this has happened
        NSError* error = [NSError createKCSError:@"Entity dictionary not returned for user" code:401 userInfo:@{@"body":body}];
        if (completionBlock) completionBlock(nil, error);
        return;
    }
    
    NSString* userId = body[KCSEntityKeyId];
    NSString* username = body [KCSUserAttributeUsername];
    if (userId == nil || username == nil) {
        //prevent that weird assertion that Colden was seeing
        NSError* error = [NSError createKCSError:@"Entity dictionary does not have username or user id" code:401 userInfo:@{@"body":body}];
        if (completionBlock) completionBlock(nil, error);
        return;
    }
    
    //Strip token
    NSMutableDictionary* modifiedProperties = [body mutableCopy];
    [modifiedProperties removeObjectForKey:KCSUserAttributePassword]; //discard the password in all cases
    
    NSMutableDictionary* metadata = [NSMutableDictionary dictionaryWithDictionary:modifiedProperties[KCSEntityKeyKMD]];
    
    NSString* authToken = nil;
    if (checkAuth) {
        authToken = [metadata popObjectForKey:KCSEntityKeyAuthtoken];
        
        if (authToken == nil) {
            NSError* error = [NSError createKCSError:@"Entity dictionary does not contain an auth token" code:401 userInfo:@{@"body":body}];
            if (completionBlock) completionBlock(nil, error);
            return;
        }
    }
    
    //Handle Email Verification
    NSDictionary* emailVerification = [metadata popObjectForKey:KCSEntityKeyEmailVerification];
    NSString* verificationStatus = [emailVerification objectForKey:@"status"];
    
    //Put the updated properties back
    modifiedProperties[KCSEntityKeyMetadata] = metadata;
    
    //Make the user object
    KCSCollection* userCollection = [KCSCollection userCollection];
    id<KCSUser2> user = (id<KCSUser2>) [[KCSAppdataStore caches].dataModel objectFromCollection:userCollection.collectionName data:modifiedProperties];
    user.emailVerified = [verificationStatus isEqualToString:@"confirmed"];
    
    if (user.userId == nil || user.username == nil) {
        //prevent that weird assertion that Colden was seeing
        NSError* error = [NSError createKCSError:@"User object not properly configured with _id and username" code:401 userInfo:@{@"body":body}];
        if (completionBlock) completionBlock(nil, error);
        return;
    }
    
    if (checkAuth) {
        [KCSKeychain2 setKinveyToken:authToken user:userId];
    }
    [self setActive:user];
    [[KCSAppdataStore caches] cacheActiveUser:user];

#if TARGET_OS_IOS
    [[KCSPush sharedPush] registerDeviceToken:^(BOOL success, NSError *error) {
        if (completionBlock) completionBlock(user, nil);
    }];
#endif
}

+(KCSRequest*)changePasswordForUser:(id<KCSUser2>)user
                           password:(NSString*)newPassword
                         completion:(KCSUser2CompletionBlock)completionBlock
{
    SWITCH_TO_MAIN_THREAD_USER2_BLOCK(completionBlock);
    if (newPassword == nil) {
        [[NSException exceptionWithName:NSInvalidArgumentException reason:@"newPassword is nil" userInfo:nil] raise];
    }
    if (![user isEqual:[KCSUser activeUser]]){
        NSDictionary *userInfo = @{NSLocalizedDescriptionKey: @"Receiver is not current user.",
                                   NSLocalizedFailureReasonErrorKey: @"An operation only applicable to the current user was tried on a different user.",
                                   NSLocalizedRecoverySuggestionErrorKey:@"Only perform this action on the active user"};
        NSError *userError = [NSError createKCSError:KCSUserErrorDomain code:KCSOperationRequiresCurrentUserError userInfo:userInfo];
        if (completionBlock) completionBlock(nil, userError);
        return nil;
    } else {
        KCSCollection* userCollection = [KCSCollection userCollection];
        NSDictionary<NSString*, id>* entity = [[KCSAppdataStore caches].dataModel jsonEntityForObject:user route:[userCollection route] collection:userCollection.collectionName];
        
        __weak __block NSMutableDictionary<NSString*, id>* (^transformWeak)(NSMutableDictionary<NSString*, id>* object) = nil;
        NSMutableDictionary<NSString*, id>* (^transform)(NSMutableDictionary<NSString*, id>* object) = ^(NSMutableDictionary<NSString*, id>* object) {
            id value;
            NSMutableDictionary<NSString*, id>* copyObject = object.mutableCopy;
            for (NSString* key in object) {
                value = copyObject[key];
                if ([value isKindOfClass:[NSDictionary class]]) {
                    copyObject[key] = transformWeak(value);
                } else if ([value isKindOfClass:[NSSet class]]) {
                    copyObject[key] = ((NSSet*) value).allObjects;
                }
            }
            return copyObject;
        };
        transformWeak = transform;
        entity = transform(entity.mutableCopy);
        
        NSDictionary* body = [entity dictionaryByAddingDictionary:@{KCSUserAttributePassword : newPassword}];
        
        KCSHttpRequest* request = [KCSHttpRequest requestWithCompletion:^(KCSNetworkResponse *response, NSError *error) {
            if (error) {
                KCSLogNSError(KCS_LOG_CONTEXT_USER, error);
                if (completionBlock) completionBlock(nil, error);
            } else {
                // Ok, we're really auth'd
                NSDictionary* userBody = [response jsonObjectError:&error];
                if (error) {
                    if (completionBlock) completionBlock(nil, error);
                } else {
                    [self setupActiveUser:userBody completion:completionBlock checkAuth:YES];
                }
            }
            
        }
                                                            route:KCSRESTRouteUser
                                                          options:@{KCSRequestLogMethod}
                                                      credentials:[KCSUser activeUser]];
        request.method = KCSRESTMethodPUT;
        request.path = @[user.userId];
        request.body = body;
        return [KCSRequest requestWithNetworkOperation:[request start]];
    }
}

+(KCSRequest*)refreshUser:(id<KCSUser2>)user
                  options:(NSDictionary*)options
               completion:(KCSUser2CompletionBlock)completionBlock
{
    SWITCH_TO_MAIN_THREAD_USER2_BLOCK(completionBlock);
    //options to use in the future for loading references, etc
    if (![user isEqual:[KCSUser activeUser]]){
        KCSLogError(KCS_LOG_CONTEXT_USER, @"Attempted to refresh a user who is not the KinveyKit Active User!");
        NSDictionary *userInfo = @{NSLocalizedDescriptionKey: @"User refresh is not on active user"};
        NSError *userError = [NSError createKCSError:KCSUserErrorDomain code:KCSOperationRequiresCurrentUserError userInfo:userInfo];
        if (completionBlock) completionBlock(nil, userError);
        return nil;
    }
    if (user.userId == nil) {
        KCSLogError(KCS_LOG_CONTEXT_USER, @"Error refreshing user, no user id.");
        NSDictionary* errorInfo =  @{NSLocalizedDescriptionKey:@"User has no _id."};
        NSError* error = [NSError createKCSError:KCSUserErrorDomain code:KCSUserObjectNotActiveError userInfo:errorInfo];
        if (completionBlock) completionBlock(nil, error);
        return nil;
    }
    
    KCSHttpRequest* request = [KCSHttpRequest requestWithCompletion:^(KCSNetworkResponse *response, NSError *error) {
        if (error) {
            KCSLogError(KCS_LOG_CONTEXT_USER, @"Error Updating user: %@", error);
            if (completionBlock) completionBlock(user, error);
        } else {
            if ([KCSUser activeUser] != user) { // still have to check here because active user can be reset while loading request
                KCSLogError(KCS_LOG_CONTEXT_USER, @"Attempted to refresh a user who is not the KinveyKit Active User!");
                NSDictionary *userInfo = @{NSLocalizedDescriptionKey: @"User refresh is not on active user"};
                NSError *userError = [NSError createKCSError:KCSUserErrorDomain code:KCSOperationRequiresCurrentUserError userInfo:userInfo];
                if (completionBlock) completionBlock(user, userError);
            } else {
                NSDictionary* userBody = [response jsonObjectError:&error];
                if (error) {
                    if (completionBlock) completionBlock(user, error);
                } else {
                    [self setupActiveUser:userBody completion:completionBlock checkAuth:NO];
                }
            }
        }
    }
                                                        route:KCSRESTRouteUser
                                                      options:@{KCSRequestLogMethod}
                                                  credentials:user];
    request.path = @[user.userId];
    return [KCSRequest requestWithNetworkOperation:[request start]];
}

+(KCSRequest*)saveUser:(id<KCSUser2>)user
               options:(NSDictionary*)options
            completion:(KCSUser2CompletionBlock)completionBlock
{
    SWITCH_TO_MAIN_THREAD_USER2_BLOCK(completionBlock);
    //options for future with references and such
    
    if (![user isEqual:[KCSUser activeUser]]){
        KCSLogError(KCS_LOG_CONTEXT_USER, @"Attempted to save a user who is not the KinveyKit Active User!");
        NSDictionary *userInfo = @{NSLocalizedDescriptionKey: @"Receiver is not current user"};
        NSError *userError = [NSError createKCSError:KCSUserErrorDomain code:KCSOperationRequiresCurrentUserError userInfo:userInfo];
        if (completionBlock) completionBlock(nil, userError);
        return nil;
    }
    if (user.userId == nil) {
        KCSLogError(KCS_LOG_CONTEXT_USER, @"Error save user, no user id.");
        NSDictionary* errorInfo =  @{NSLocalizedDescriptionKey:@"User object save needs and established user."};
        NSError* error = [NSError createKCSError:KCSUserErrorDomain code:KCSUserObjectNotActiveError userInfo:errorInfo];
        if (completionBlock) completionBlock(nil, error);
        return nil;
    }
    
    NSDictionary* entity = [[KCSAppdataStore caches].dataModel jsonEntityForObject:user route:KCSRESTRouteUser collection:KCSUserCollectionName];
    
    KCSHttpRequest* request = [KCSHttpRequest requestWithCompletion:^(KCSNetworkResponse *response, NSError *error) {
        if (error) {
            KCSLogError(KCS_LOG_CONTEXT_USER, @"Error Updating user: %@", error);
            if (completionBlock) completionBlock(user, error);
        } else {
            NSDictionary* userBody = [response jsonObjectError:&error];
            if (error) {
                if (completionBlock) completionBlock(user, error);
            } else {
                [self setupActiveUser:userBody completion:completionBlock checkAuth:YES];
            }
        }
    }
                                                        route:KCSRESTRouteUser
                                                      options:@{KCSRequestLogMethod}
                                                  credentials:user];
    request.method = KCSRESTMethodPUT;
    request.path = @[user.userId];
    request.body = entity;
    return [KCSRequest requestWithNetworkOperation:[request start]];
}

+(KCSRequest*)deleteUser:(id<KCSUser2>)user
                 options:(NSDictionary*)options
              completion:(KCSCountBlock)completionBlock
{
    SWITCH_TO_MAIN_THREAD_COUNT_BLOCK(completionBlock);
    if (![user isEqual:[KCSUser activeUser]]){
        KCSLogError(KCS_LOG_CONTEXT_USER, @"Attempted to delete a user who is not the KinveyKit Active User!");
        NSDictionary *userInfo = @{NSLocalizedDescriptionKey: @"Receiver is not current user"};
        NSError *userError = [NSError createKCSError:KCSUserErrorDomain code:KCSOperationRequiresCurrentUserError userInfo:userInfo];
        if (completionBlock) completionBlock(0, userError);
        return nil;
    }
    if (user.userId == nil) {
        KCSLogError(KCS_LOG_CONTEXT_USER, @"Error delete user, no user id.");
        NSDictionary* errorInfo =  @{NSLocalizedDescriptionKey:@"User object delete needs and established user."};
        NSError* error = [NSError createKCSError:KCSUserErrorDomain code:KCSUserObjectNotActiveError userInfo:errorInfo];
        if (completionBlock) completionBlock(0, error);
        return nil;
    }
    
    KCSHttpRequest* request = [KCSHttpRequest requestWithCompletion:^(KCSNetworkResponse *response, NSError *error) {
        if (error != nil) {
            [self logoutUser:user];
        }
        if (completionBlock) completionBlock(error != nil, error);
    }
                                                        route:KCSRESTRouteUser
                                                      options:@{KCSRequestLogMethod}
                                                  credentials:user];
    request.method = KCSRESTMethodDELETE;
    request.path = @[user.userId];
    return [KCSRequest requestWithNetworkOperation:[request start]];
}

+(KCSRequest*)sendPasswordResetForUsername:(NSString*)username
                                completion:(KCSUserSendEmailBlock)completionBlock
{
    SWITCH_TO_MAIN_THREAD_USER_SEND_EMAIL_BLOCK(completionBlock);
    // /rpc/:kid/:username/user-password-reset-initiate
    // /rpc/:kid/:email/user-password-reset-initiaxte
    if (username == nil) {
        [[NSException exceptionWithName:NSInvalidArgumentException reason:@"username cannot be nil" userInfo:nil] raise];
    }
    KCSHttpRequest* request = [KCSHttpRequest requestWithCompletion:^(KCSNetworkResponse *response, NSError *error) {
        //response will be a 204 if accepted by server
        if (completionBlock) completionBlock(response.code == KCS_HTTP_STATUS_NO_CONTENT, error);
    }
                                                        route:KCSRESTRouteRPC
                                                      options:@{KCSRequestLogMethod}
                                                  credentials:[KCSClient2 sharedClient]];
    request.method = KCSRESTMethodPOST;
    request.path = @[username, @"user-password-reset-initiate"];
    return [KCSRequest requestWithNetworkOperation:[request start]];
}

+(KCSRequest*)sendPasswordResetForEmail:(NSString*)email
                             completion:(KCSUserSendEmailBlock)completionBlock
{
    SWITCH_TO_MAIN_THREAD_USER_SEND_EMAIL_BLOCK(completionBlock);
    // /rpc/:kid/:email/user-password-reset-initiate
    if (email == nil) {
        [[NSException exceptionWithName:NSInvalidArgumentException reason:@"email cannot be nil" userInfo:nil] raise];
    }
    KCSHttpRequest* request = [KCSHttpRequest requestWithCompletion:^(KCSNetworkResponse *response, NSError *error) {
        //response will be a 204 if accepted by server
        if (completionBlock) completionBlock(response.code == KCS_HTTP_STATUS_NO_CONTENT, error);
    }
                                                        route:KCSRESTRouteRPC
                                                      options:@{KCSRequestLogMethod}
                                                  credentials:[KCSClient2 sharedClient]];
    request.method = KCSRESTMethodPOST;
    request.path = @[email, @"user-password-reset-initiate"];
    return [KCSRequest requestWithNetworkOperation:[request start]];
}

+(KCSRequest*)sendEmailConfirmationForUser:(NSString*)username
                                completion:(KCSUserSendEmailBlock)completionBlock
{
    SWITCH_TO_MAIN_THREAD_USER_SEND_EMAIL_BLOCK(completionBlock);
    //req.post /rpc/:kid/:username/user-email-verification-initiate
    if (username == nil) {
        [[NSException exceptionWithName:NSInvalidArgumentException reason:@"username cannot be nil" userInfo:nil] raise];
    }
    KCSHttpRequest* request = [KCSHttpRequest requestWithCompletion:^(KCSNetworkResponse *response, NSError *error) {
        //response will be a 204 if accepted by server
        if (completionBlock) completionBlock(response.code == KCS_HTTP_STATUS_NO_CONTENT, error);
    }
                                                        route:KCSRESTRouteRPC
                                                      options:@{KCSRequestLogMethod}
                                                  credentials:[KCSClient2 sharedClient]];
    request.method = KCSRESTMethodPOST;
    request.path = @[username, @"user-email-verification-initiate"];
    return [KCSRequest requestWithNetworkOperation:[request start]];
}

+(KCSRequest*)sendForgotUsernameEmail:(NSString*)email
                           completion:(KCSUserSendEmailBlock)completionBlock
{
    SWITCH_TO_MAIN_THREAD_USER_SEND_EMAIL_BLOCK(completionBlock);
    if (email == nil) {
        [[NSException exceptionWithName:NSInvalidArgumentException reason:@"email cannot be nil" userInfo:nil] raise];
    }
    
    KCSHttpRequest* request = [KCSHttpRequest requestWithCompletion:^(KCSNetworkResponse *response, NSError *error) {
        //response will be a 204 if accepted by server
        if (completionBlock) completionBlock(response.code == KCS_HTTP_STATUS_NO_CONTENT, error);
    }
                                                        route:KCSRESTRouteRPC
                                                      options:@{KCSRequestLogMethod}
                                                  credentials:[KCSClient2 sharedClient]];
    request.method = KCSRESTMethodPOST;
    request.path = @[@"user-forgot-username"];
    request.body = @{@"email" : email};
    return [KCSRequest requestWithNetworkOperation:[request start]];
}

+(KCSRequest*)checkUsername:(NSString*)potentialUsername
                 completion:(KCSUserCheckUsernameBlock)completionBlock
{
    SWITCH_TO_MAIN_THREAD_USER_CHECK_USERNAME_BLOCK(completionBlock);
    if (potentialUsername == nil) {
        [[NSException exceptionWithName:NSInvalidArgumentException reason:@"potentialUsername cannot be nil" userInfo:nil] raise];
    }
    
    // /rpc/:appKey/check-username-exists
    KCSHttpRequest* request = [KCSHttpRequest requestWithCompletion:^(KCSNetworkResponse *response, NSError *error) {
        //response will be a 204 if accepted by server
        if (!error) {
            response.skipValidation = YES;
            NSDictionary* dict = [response jsonObjectError:&error];
            if (error) {
                if (completionBlock) completionBlock(potentialUsername, NO, error);
            } else {
                if (completionBlock) completionBlock(potentialUsername, [dict[@"usernameExists"] boolValue], error);
            }
        } else {
            if (completionBlock) completionBlock(potentialUsername, NO, error);
        }
    }
                                                        route:KCSRESTRouteRPC
                                                      options:@{KCSRequestLogMethod}
                                                  credentials:[KCSClient2 sharedClient]];
    request.method = KCSRESTMethodPOST;
    request.path = @[@"check-username-exists"];
    request.body = @{@"username": potentialUsername};
    return [KCSRequest requestWithNetworkOperation:[request start]];
}

@end

#pragma clang diagnostic pop
